# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Sort Matrix by Column
#' 
#' Sorts a given matrix by a specific column while retain the elements in each row.
#' 
#' @param x   A \code{matrix} to sort
#' @param col A \code{int} that indicates the column the matrix should sort by.
#' @details 
#' The functional difference between armadillo's sort() and sort_mat() is straight forward.
#' sort() will sort each column without respect to the rows. 
#' Using sort_matrix will sort only 1 column and retain the other elements to be in the same row.
#' @return The matrix sorted by values in the specified column.
#' @keywords internal
sort_mat <- function(x, col) {
    .Call('gmwm2_sort_mat', PACKAGE = 'gmwm2', x, col)
}

#' @title Reverse Subset Column
#' @description 
#' Subsets the column by going from high indices to low (the reverse of the supported practice)
#' @param x     A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting column.
#' @param end   A \code{unsigned int} that indicates the ending column.
#' @return x A \code{matrix} with matrix rows displayed in reverse order
#' @details Consider a vector x=[[1,2],[3,4]].
#' By setting \code{start=1} and \code{end=0}, the function would output x=[[2,1],[4,1]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow = 2,byrow = TRUE)
#' rev_col_subset(x, 1, 0)
#' @keywords internal
rev_col_subset <- function(x, start, end) {
    .Call('gmwm2_rev_col_subset', PACKAGE = 'gmwm2', x, start, end)
}

#' @title Reverse Subset Row
#' @description Subsets the row by going from high indices to low (the reverse of the supported practice)
#' @param x      A \code{matrix} of dimensions M x N
#' @param start  A \code{unsigned int} that indicates the starting row.
#' @param end    A \code{unsigned int} that indicates the ending row.
#' @return x A \code{matrix} with matrix rows displayed in reversed order
#' @details Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow=2,byrow=TRUE)
#' rev_row_subset(x, 1, 0)
#' @keywords internal
rev_row_subset <- function(x, start, end) {
    .Call('gmwm2_rev_row_subset', PACKAGE = 'gmwm2', x, start, end)
}

#' @title Reverse Armadillo Vector
#' @description Reverses the order of an Armadillo Vector
#' @usage reverse_vec(x)
#' @param x A \code{column vector} of length N
#' @return x A \code{column vector} with its contents reversed.
#' @details Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
#' @author JJB
#' @examples
#' x = 1:5
#' reverse_vec(x)
#' @keywords internal
reverse_vec <- function(x) {
    .Call('gmwm2_reverse_vec', PACKAGE = 'gmwm2', x)
}

#' @title Transform an Armadillo field<vec> to a matrix
#' @description Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author JJB
#' @examples
#' x=rnorm(100)
#' @keywords internal
field_to_matrix <- function(x) {
    .Call('gmwm2_field_to_matrix', PACKAGE = 'gmwm2', x)
}

#' @title Accumulation of Armadillo field<vec>
#' @description Sums vectors in a field into a single variable.
#' @param x A \code{field<vec>}.
#' @return An \code{mat} containing the field elements within a column.
#' @author JJB
#' @examples
#' x=rnorm(100)
#' @keywords internal
sum_field_vec <- function(x) {
    .Call('gmwm2_sum_field_vec', PACKAGE = 'gmwm2', x)
}

#' @title Discrete Wavelet Transform
#' @description Calculation of the coefficients for the discrete wavelet transformation.
#' @param x           A \code{vector} with dimensions \eqn{N\times 1}{N x 1}.
#' @param filter_name A \code{string} indicating the filter.
#' @param nlevels     An \code{integer}, \eqn{J}, indicating the level of the decomposition.
#' @param boundary    A \code{string} indicating the type of boundary method to use. Either \code{boundary="periodic"} or \code{"reflection"}.
#' @param brickwall   A \code{bool} indicating whether the a brick wall procedure should be applied to the coefficients.
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm
#' @author JJB
#' @keywords internal
#' @examples
#' set.seed(999)
#' x = rnorm(2^8)
#' dwt_cpp(x, filter_name = "haar", nlevels = 4, boundary = "periodic", brickwall = TRUE)
dwt_cpp <- function(x, filter_name, nlevels, boundary, brickwall) {
    .Call('gmwm2_dwt_cpp', PACKAGE = 'gmwm2', x, filter_name, nlevels, boundary, brickwall)
}

#' @title Maximum Overlap Discrete Wavelet Transform
#' @description
#' Calculation of the coefficients for the discrete wavelet transformation
#' @inheritParams dwt_cpp
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @keywords internal
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm.
#' Use this implementation to supply custom parameters instead of modwt(x),
#' which serves as a wrapper function.
#' @author JJB
#' @keywords internal
#' @examples
#' set.seed(999)
#' x = rnorm(100)
#' modwt_cpp(x, filter_name = "haar", nlevels = 4, boundary = "periodic", brickwall = TRUE)
modwt_cpp <- function(x, filter_name, nlevels, boundary, brickwall) {
    .Call('gmwm2_modwt_cpp', PACKAGE = 'gmwm2', x, filter_name, nlevels, boundary, brickwall)
}

#' @title Removal of Boundary Wavelet Coefficients
#' @description Removes the first n wavelet coefficients.
#' @param x           A \code{field<vec>} that contains the nlevel decomposition using either modwt or dwt.
#' @param wave_filter A \code{field<vec>} containing filter information. Only "haar" is implemented.
#' @param method      A \code{string} to describe the mode. Choose between "modwt" and "dwt"
#' @return A \code{field<vec>} with boundary modwt or dwt taken care of.
#' @keywords internal
#' @details
#' The vectors are truncated by removing the first n wavelet coefficients.
#' These vectors are then stored into the field that is returned.
#' Note: As a result, there are no NA's introduced and hence the na.omit is not needed.
#' @examples
#' x = rnorm(100)
#' me = modwt_cpp(x, filter_name = "haar", nlevels = 4, boundary = "periodic", brickwall = FALSE)
#' brick_wall(me, select_filter("haar"), "modwt")
brick_wall <- function(x, wave_filter, method) {
    .Call('gmwm2_brick_wall', PACKAGE = 'gmwm2', x, wave_filter, method)
}

#' @title Quadrature Mirror Filter
#' @description Calculate the series quadrature mirror filter (QMF). Requires a series of an even length.
#' @usage qmf(g, inverse)
#' @param g A \code{vector} that contains the filter constants.
#' @param inverse A \code{bool} that indicates whether the inverse quadrature mirror filter is computed. 
#' By default, the inverse quadrature mirror is computed.
#' @return A \code{vector} that contains either the forward QMF (evalute in order) or the inverse QMF (reverse order). 
#' @author JJB
#' @keywords internal
#' @examples
#' # Haar values
#' g = rep(1/sqrt(2),2)
#' qmf(g)
qmf <- function(g, inverse = TRUE) {
    .Call('gmwm2_qmf', PACKAGE = 'gmwm2', g, inverse)
}

#' @title Haar filter construction
#' @description Creates the haar filter
#' @usage haar_filter()
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' haar_filter()
haar_filter <- function() {
    .Call('gmwm2_haar_filter', PACKAGE = 'gmwm2')
}

#' @title d4 filter construction
#' @description Creates the d4 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' d4_filter()
d4_filter <- function() {
    .Call('gmwm2_d4_filter', PACKAGE = 'gmwm2')
}

#' @title mb4 filter construction
#' @description Creates the mb4 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' mb4_filter()
mb4_filter <- function() {
    .Call('gmwm2_mb4_filter', PACKAGE = 'gmwm2')
}

#' @title w4 filter construction
#' @description Creates the w4 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' w4_filter()
w4_filter <- function() {
    .Call('gmwm2_w4_filter', PACKAGE = 'gmwm2')
}

#' @title fk4 filter construction
#' @description Creates the fk4 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' fk4_filter()
fk4_filter <- function() {
    .Call('gmwm2_fk4_filter', PACKAGE = 'gmwm2')
}

#' @title d6 filter construction
#' @description Creates the d6 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' d6_filter()
d6_filter <- function() {
    .Call('gmwm2_d6_filter', PACKAGE = 'gmwm2')
}

#' @title fk6 filter construction
#' @description Creates the fk6 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' fk6_filter()
fk6_filter <- function() {
    .Call('gmwm2_fk6_filter', PACKAGE = 'gmwm2')
}

#' @title d8 filter construction
#' @description Creates the d8 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' d8_filter()
d8_filter <- function() {
    .Call('gmwm2_d8_filter', PACKAGE = 'gmwm2')
}

#' @title fk8 filter construction
#' @description Creates the fk8 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' fk8_filter()
fk8_filter <- function() {
    .Call('gmwm2_fk8_filter', PACKAGE = 'gmwm2')
}

#' @title la8 filter construction
#' @description Creates the la8 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' la8_filter()
la8_filter <- function() {
    .Call('gmwm2_la8_filter', PACKAGE = 'gmwm2')
}

#' @title mb8 filter construction
#' @description Creates the mb8 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' mb8_filter()
mb8_filter <- function() {
    .Call('gmwm2_mb8_filter', PACKAGE = 'gmwm2')
}

#' @title bl14 filter construction
#' @description Creates the bl14 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' bl14_filter()
bl14_filter <- function() {
    .Call('gmwm2_bl14_filter', PACKAGE = 'gmwm2')
}

#' @title fk14 filter construction
#' @description Creates the fk14 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' fk14_filter()
fk14_filter <- function() {
    .Call('gmwm2_fk14_filter', PACKAGE = 'gmwm2')
}

#' @title d16 filter construction
#' @description Creates the d16 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' d16_filter()
d16_filter <- function() {
    .Call('gmwm2_d16_filter', PACKAGE = 'gmwm2')
}

#' @title la16 filter construction
#' @description Creates the la16 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' la16_filter()
la16_filter <- function() {
    .Call('gmwm2_la16_filter', PACKAGE = 'gmwm2')
}

#' @title mb16 filter construction
#' @description Creates the mb16 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' mb16_filter()
mb16_filter <- function() {
    .Call('gmwm2_mb16_filter', PACKAGE = 'gmwm2')
}

#' @title la20 filter construction
#' @description Creates the la20 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' la20_filter()
la20_filter <- function() {
    .Call('gmwm2_la20_filter', PACKAGE = 'gmwm2')
}

#' @title bl20 filter construction
#' @description Creates the bl20 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' bl20_filter()
bl20_filter <- function() {
    .Call('gmwm2_bl20_filter', PACKAGE = 'gmwm2')
}

#' @title fk22 filter construction
#' @description Creates the fk22 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' fk22_filter()
fk22_filter <- function() {
    .Call('gmwm2_fk22_filter', PACKAGE = 'gmwm2')
}

#' @title mb24 filter construction
#' @description Creates the mb24 filter
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @keywords internal
#' @examples
#' mb24_filter()
mb24_filter <- function() {
    .Call('gmwm2_mb24_filter', PACKAGE = 'gmwm2')
}

#' @title Select the Wavelet Filter
#' @description Constructs the wavelet filter to be used.
#' @usage select_filter(filter_name)
#' @param filter_name A \code{String} that must receive: \code{"haar"}.
#' @return info A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details 
#' The package is oriented toward using only the haar filter. If the package extends at a later time, then the supporting infrastructure is there.
#' @author JJB
#' @keywords internal
#' @examples
#' select_filter("haar")
select_filter <- function(filter_name = "haar") {
    .Call('gmwm2_select_filter', PACKAGE = 'gmwm2', filter_name)
}

