# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Compute Tau-Overlap Allan Variance
#' @description Computation of Tau-Overlap Allan Variance
#' @usage avar_to_cpp(x)
#' @param x A \code{vector} with dimensions N x 1. 
#' @return av A \code{matrix} that contains:
#' \itemize{
#'  \item{Col 1}{The size of the cluster}
#'  \item{Col 2}{The Allan variance}
#'  \item{Col 3}{The error associated with the variance estimation.}
#' }
#' @details
#' Given \eqn{N} equally spaced samples with averaging time \eqn{\tau = n\tau _0}{tau = n*tau_0},
#' where \eqn{n} is an integer such that \eqn{ 1 \le n \le \frac{N}{2}}{1<= n <= N/2}.
#' Therefore, \eqn{n} is able to be selected from \eqn{\left\{ {n|n < \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}}{{n|n< floor(log2(N))}}
#' Then, a sampling of \eqn{m = \left\lfloor {\frac{{N - 1}}{n}} \right\rfloor  - 1} samples exist. 
#' The tau-overlap estimator is given by:
#' 
#' where \eqn{ {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} }.
#' 
#' @author James Balamuta
#' @references Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
#' @examples
#' set.seed(999)
#' # Simulate white noise (P 1) with sigma^2 = 4
#' N = 100000
#' white.noise = rnorm(N, 0, 2)
#' #plot(white.noise,ylab="Simulated white noise process",xlab="Time",type="o")
#' #Simulate random walk (P 4)
#' random.walk = cumsum(0.1*rnorm(N, 0, 2))
#' combined.ts = white.noise+random.walk
#' av_mat = avar_to_cpp(combined.ts)
#' @keywords internal
avar_to_cpp <- function(x) {
    .Call('wv_avar_to_cpp', PACKAGE = 'wv', x)
}

#' @title Compute Maximal-Overlap Allan Variance using Means
#' @description Computation of Maximal-Overlap Allan Variance
#' @usage avar_mo_cpp(x)
#' @param x A \code{vector} with dimensions N x 1. 
#' @return av A \code{list} that contains:
#' \itemize{
#'  \item{"clusters"}{The size of the cluster}
#'  \item{"allan"}{The Allan variance}
#'  \item{"errors"}{The error associated with the variance estimation.}
#' }
#' @details
#' Given \eqn{N} equally spaced samples with averaging time \eqn{\tau = n\tau _0}{tau = n*tau_0},
#' where \eqn{n} is an integer such that \eqn{ 1 \le n \le \frac{N}{2}}{1<= n <= N/2}.
#' Therefore, \eqn{n} is able to be selected from \eqn{\left\{ {n|n < \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}}{{n|n< floor(log2(N))}}
#' Then, \eqn{M = N - 2n} samples exist. 
#' The Maximal-overlap estimator is given by:
#' \eqn{\frac{1}{{2\left( {N - 2k + 1} \right)}}\sum\limits_{t = 2k}^N {{{\left[ {{{\bar Y}_t}\left( k \right) - {{\bar Y}_{t - k}}\left( k \right)} \right]}^2}} }
#' 
#' where \eqn{ {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} }.
#' @author James Balamuta
#' @references Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
#' @examples
#' set.seed(999)
#' # Simulate white noise (P 1) with sigma^2 = 4
#' N = 100000
#' white.noise = rnorm(N, 0, 2)
#' #plot(white.noise,ylab="Simulated white noise process",xlab="Time",type="o")
#' #Simulate random walk (P 4)
#' random.walk = cumsum(0.1*rnorm(N, 0, 2))
#' combined.ts = white.noise+random.walk
#' av_mat = avar_mo_cpp(combined.ts)
#' @keywords internal
avar_mo_cpp <- function(x) {
    .Call('wv_avar_mo_cpp', PACKAGE = 'wv', x)
}

#' @title Discrete Wavelet Transform
#' @description Calculation of the coefficients for the discrete wavelet transformation.
#' @param x           A \code{vector} with dimensions \eqn{N\times 1}{N x 1}.
#' @param filter_name A \code{string} indicating the filter.
#' @param nlevels     An \code{integer}, \eqn{J}, indicating the level of the decomposition.
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm
#' @author James Balamuta and Justin Lee
#' @keywords internal
#' @examples
#' set.seed(999)
#' x = rnorm(2^8)
#' dwt_cpp(x, filter_name = "haar", nlevels = 4)
#' @export
dwt_cpp <- function(x, filter_name, nlevels) {
    .Call('wv_dwt_cpp', PACKAGE = 'wv', x, filter_name, nlevels)
}

#' @title Maximum Overlap Discrete Wavelet Transform
#' @description
#' Calculation of the coefficients for the discrete wavelet transformation
#' @inheritParams dwt_cpp
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @keywords internal
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm.
#' Use this implementation to supply custom parameters instead of modwt(x),
#' which serves as a wrapper function.
#' @author James Balamuta and Justin Lee
#' @keywords internal
#' @examples
#' set.seed(999)
#' x = rnorm(100)
#' modwt_cpp(x, filter_name = "haar", nlevels = 4)
#' @export
modwt_cpp <- function(x, filter_name, nlevels) {
    .Call('wv_modwt_cpp', PACKAGE = 'wv', x, filter_name, nlevels)
}

#' Compute the Spatial Wavelet Coefficients
#' @param X      is a matrix with row, col orientation
#' @param J1,J2  is the levels of decomposition along the rows, columns
#' @export
#' @return A \code{list} of \code{vectors} containing the wavelet coefficients.
#' @details 
#' By default this function will return the wavelet coefficient in
#' addition to the wavelet
sp_modwt <- function(X, J1, J2) {
    .Call('wv_sp_modwt', PACKAGE = 'wv', X, J1, J2)
}

#' Haar filter for a spatial case
#' @param jscale An \code{int} of the Number of Scales
#' @export
sp_hfilter <- function(jscale) {
    .Call('wv_sp_hfilter', PACKAGE = 'wv', jscale)
}

#' @title Generate eta3 confidence interval
#' @description Computes the eta3 CI 
#' @param y          A \code{vec} that computes the modwt dot product of each wavelet coefficient divided by their length.
#' @param dims       A \code{String} indicating the confidence interval being calculated.
#' @param alpha_ov_2 A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level 
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @keywords internal
#' @export
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, filter_name = "haar", nlevels = 4)
#' y = wave_variance(decomp)
#' ci_wave_variance(decomp, y, type = "eta3", alpha_ov_2 = 0.025)
ci_eta3 <- function(y, dims, alpha_ov_2) {
    .Call('wv_ci_eta3', PACKAGE = 'wv', y, dims, alpha_ov_2)
}

#' @title Generate eta3 robust confidence interval
#' @description Computes the eta3 robust CI
#' @param wv_robust   A \code{vec} that computes the modwt dot product of each wavelet coefficient divided by their length.
#' @param wv_ci_class A \code{mat} that contains the CI mean, CI Lower, and CI Upper
#' @param alpha_ov_2  A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level
#' @param eff         A \code{double} that indicates the efficiency.
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Robust Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @details
#' Within this function we are scaling the classical 
#' @keywords internal
#' @export
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, filter_name = "haar", nlevels = 4)
#' y = wave_variance(decomp, robust = TRUE,  eff = 0.6)
#' ci_wave_variance(decomp, y, type = "eta3", alpha_ov_2 = 0.025, robust = TRUE, eff = 0.6)
ci_eta3_robust <- function(wv_robust, wv_ci_class, alpha_ov_2, eff) {
    .Call('wv_ci_eta3_robust', PACKAGE = 'wv', wv_robust, wv_ci_class, alpha_ov_2, eff)
}

#' @title Generate a Confidence interval for a Univariate Time Series
#' @description Computes an estimate of the multiscale variance and a chi-squared confidence interval
#' @param signal_modwt_bw A \code{field<vec>} that contains the modwt or dwt decomposition
#' @param wv              A \code{vec} that contains the wave variance.
#' @param type            A \code{String} indicating the confidence interval being calculated.
#' @param alpha_ov_2      A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level.
#' @param robust          A \code{boolean} to determine the type of wave estimation.
#' @param eff             A \code{double} that indicates the efficiency.
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @keywords internal
#' @export
#' @details 
#' This function can be expanded to allow for other confidence interval calculations.
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, filter_name = "haar", nlevels = 4)
#' y = wave_variance(decomp)
#' ci_wave_variance(decomp, y, type = "eta3", alpha_ov_2 = 0.025)
ci_wave_variance <- function(signal_modwt_bw, wv, type = "eta3", alpha_ov_2 = 0.025, robust = FALSE, eff = 0.6) {
    .Call('wv_ci_wave_variance', PACKAGE = 'wv', signal_modwt_bw, wv, type, alpha_ov_2, robust, eff)
}

#' @title Generate a Wave Variance for a Univariate Time Series
#' @description Computes an estimate of the wave variance
#' @param signal_modwt_bw A \code{field<vec>} that contains the modwt or dwt decomposition
#' @param robust          A \code{boolean} to determine the type of wave estimation.
#' @param eff             A \code{double} that indicates the efficiency.
#' @return A \code{vec} that contains the wave variance.
#' @keywords internal
#' @export
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' decomp = modwt_cpp(x, filter_name = "haar", nlevels = 4)
#' wave_variance(decomp)
#' 
#' wave_variance(decomp, robust = TRUE, eff = 0.6)
wave_variance <- function(signal_modwt_bw, robust = FALSE, eff = 0.6) {
    .Call('wv_wave_variance', PACKAGE = 'wv', signal_modwt_bw, robust, eff)
}

#' @title Computes the (MODWT) wavelet variance
#' @description Calculates the (MODWT) wavelet variance
#' @param signal_modwt_bw  A \code{field<vec>} that contains the modwt decomposition after it has been brick walled.
#' @param robust           A \code{boolean} that triggers the use of the robust estimate.
#' @param eff              A \code{double} that indicates the efficiency as it relates to an MLE.
#' @param alpha            A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level 
#' @param ci_type          A \code{String} indicating the confidence interval being calculated. Valid value: "eta3"
#' @return A \code{mat} with the structure:
#' \itemize{
#'   \item{"variance"}{Wavelet Variance}
#'   \item{"low"}{Lower CI}
#'   \item{"high"}{Upper CI}
#' }
#' @keywords internal
#' @export
#' @details 
#' This function does the heavy lifting with the signal_modwt_bw
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' decomp = modwt_cpp(x, filter_name = "haar", nlevels = 4)
#' wvar_cpp(decomp, robust=FALSE, eff=0.6, alpha = 0.05, ci_type="eta3")
wvar_cpp <- function(signal_modwt_bw, robust, eff, alpha, ci_type) {
    .Call('wv_wvar_cpp', PACKAGE = 'wv', signal_modwt_bw, robust, eff, alpha, ci_type)
}

#' @title Computes the (MODWT) wavelet variance
#' @description Calculates the (MODWT) wavelet variance
#' @param signal     A \code{vec} that contains the data.
#' @param robust     A \code{boolean} that triggers the use of the robust estimate.
#' @param eff        A \code{double} that indicates the efficiency as it relates to an MLE.
#' @param alpha      A \code{double} that indicates the \eqn{\left(1-p\right)\times \alpha}{(1-p)*alpha} confidence level 
#' @param ci_type    A \code{string} indicating the confidence interval being calculated. Valid value: "eta3"
#' @param strWavelet A \code{string} indicating the type of wave filter to be applied. Must be "haar"
#' @param decomp     A \code{string} indicating whether to use "modwt" or "dwt" decomp
#' @return A \code{mat} with the structure:
#' \itemize{
#'   \item{"variance"}{Wavelet Variance}
#'   \item{"low"}{Lower CI}
#'   \item{"high"}{Upper CI}
#' }
#' @keywords internal
#' @export
#' @details 
#' This function powers the wvar object. It is also extendable...
#' @examples
#' set.seed(1337)
#' x=rnorm(100)
#' modwt_wvar_cpp(x, nlevels=4, robust=FALSE, eff=0.6, alpha = 0.05,
#'                ci_type="eta3", strWavelet="haar", decomp="modwt")
modwt_wvar_cpp <- function(signal, nlevels, robust, eff, alpha, ci_type, strWavelet, decomp) {
    .Call('wv_modwt_wvar_cpp', PACKAGE = 'wv', signal, nlevels, robust, eff, alpha, ci_type, strWavelet, decomp)
}

#' @title Computes the MO/DWT wavelet variance for multiple processes
#' @description Calculates the MO/DWT wavelet variance
#' @param signal     A \code{matrix} that contains the same number of observations per dataset
#' @param robust     A \code{boolean} that triggers the use of the robust estimate.
#' @param eff        A \code{double} that indicates the efficiency as it relates to an MLE.
#' @param alpha      A \code{double} that indicates the \eqn{\left(1-p\right)\times \alpha}{(1-p)*alpha} confidence level 
#' @param ci_type    A \code{string} indicating the confidence interval being calculated. Valid value: "eta3"
#' @param strWavelet A \code{string} indicating the type of wave filter to be applied. Must be "haar"
#' @param decomp     A \code{string} indicating whether to use "modwt" or "dwt" decomp
#' @return A \code{field<mat>} with the structure:
#' \itemize{
#'   \item{"variance"}{Wavelet Variance}
#'   \item{"low"}{Lower CI}
#'   \item{"high"}{Upper CI}
#' }
#' @keywords internal
#' @export
#' @details 
#' This function processes the decomposition of multiple signals quickly
#' @examples
#' set.seed(1337)
#' x = cbind(rnorm(100),rnorm(100))
#' batch_modwt_wvar_cpp(x, nlevels=4, robust=FALSE, eff=0.6, 
#'                      alpha = 0.05, ci_type="eta3", strWavelet="haar", 
#'                      decomp="modwt")
batch_modwt_wvar_cpp <- function(signal, nlevels, robust, eff, alpha, ci_type, strWavelet, decomp) {
    .Call('wv_batch_modwt_wvar_cpp', PACKAGE = 'wv', signal, nlevels, robust, eff, alpha, ci_type, strWavelet, decomp)
}

#' @title Computes the MODWT scales
#' @description Calculates the MODWT scales
#' @param nb_level  A \code{integer} that contains the level of decomposition J.
#' @return A \code{vec} that contains 2^1, ... , 2^J
#' @keywords internal
#' @details 
#' Used in wvar object.
#' @export
#' @examples
#' scales_cpp(5)
scales_cpp <- function(nb_level) {
    .Call('wv_scales_cpp', PACKAGE = 'wv', nb_level)
}

compute_cov_cpp <- function(coef1, coef2, variance, lower, upper) {
    .Call('wv_compute_cov_cpp', PACKAGE = 'wv', coef1, coef2, variance, lower, upper)
}

